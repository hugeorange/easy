<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
// 借用构造函数继承，缺点：属性和方法都在构造函数中定义，无法复用
function Parent() {
    this.name = "parent";
}

function Child() {
    Parent.call(this);
    this.type = "childType";
}

// 借用原型链实现继承， 缺点：如果父类的某一属性为引用类型的时候在被父类继承时，存在被篡改的可能
function Parent() {
    this.name = "Parent1"
}

function Child() {
    this.type = "child1"
}

Child.prototype = new Parent();

// 组合式继承，构造函数继承实例属性，原型链继承方法
function Parent() {
    this.name = "parent";
}
function Child() {
    Parent.call(this);
    this.type = "child";
}

Child.prototype = new Parent();
Child.prototype.constructor = Child; // 否则子类的构造函数就指向父类了



// 斐波那契亚数列  1 1 2 3 5 8 13 21 ...
function feibo (n) {
    if(n==1 || n==2) {
        return 1;
    } else {
        return f(n-1) + f(n-2);
    }
}

/**
 * 冒泡排序
 * 第一遍将最大排在最后面，第二轮就不用在比较了，就只要比较 arr.length-i-1
*/
var arr = [1,3,6,9,0,2,5]
function bubble(arr) {
    for(var i=0; i<arr.length; i++) {
        for(var j=0; j<arr.length-i-1; j++) {
            if(arr[i] > arr[j+1]) {
                var temp = arr[i];
                arr[i] = arr[j+1];
                arr[j+1] =temp;
            }
        }
    }
    return arr;
}



// 深拷贝

function deepCopy(o,c) { // o:源对象，c:拷贝生成的对象
    var c = c || {};
    for(var k in o) {
        if(typeof o[k] === 'Object') { // 复杂数据类型
            c[k] = (o[k].constructor === Array) ? [] : {};
            deepCopy(o[k], c[k]);
        }else {
            c[k] = o[k];  // 简单数据类型直接赋值
        }
    }
}

/**
 * new 一个构造函数发生了那些事
 * 1. 创建了一个新对象
 * 2. 将this指向这个新对象
 * 3. 执行构造函数里面的代码
 * 4. 返回这个 this
*/

/**
 * 当一个内部函数被其外部函数之外的变量引用时，就形成了闭包
 * 闭包一个具有封闭功能和包裹的结构，实现了私有作用域
 * 特性：1.函数嵌套函数
 *      2.函数内部引用外部的参数和变量
 *      3.参数和变量不会被垃圾回收机制回收
 * 使用场景：当我们在模块中定义一些变量，并希望这些变量一直保存在内存中，但又不会污染全局变量
 * 缺点：常驻内存中，会增大内存使用量，使用不当，容易造成内存泄漏
*/


/**
 * w3c DOM2.0 事件流
 * 事件捕获
 * 时间目标
 * 时间冒泡
*/
function bibao() {
    var a = 1;
    return function() {
        a++
    }
}

var c = bibao()();
</script>
</html>


